<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AVR135: Using Timer Capture to Measure PWM Duty Cycle: icp.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>icp.c</h1><a href="icp_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// This file has been prepared for Doxygen automatic documentation generation.</span>
<a name="l00023"></a>00023 <span class="comment"></span><span class="preprocessor">#if  __GCC__</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#include &lt;avr/io.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;avr/signal.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#else   </span><span class="comment">/* assume IAR */</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;inavr.h&gt;</span>
<a name="l00029"></a><a class="code" href="icp_8c.html#a0">00029</a> <span class="preprocessor">#define ENABLE_BIT_DEFINITIONS</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#include &lt;iom64.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#endif</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="icp_8h.html">icp.h</a>"</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="comment">/*</span>
<a name="l00035"></a>00035 <span class="comment"> * Definitions for the ICP pin; for this example we use timer 1</span>
<a name="l00036"></a>00036 <span class="comment"> */</span>
<a name="l00037"></a><a class="code" href="icp_8c.html#a1">00037</a> <span class="preprocessor">#define ICP_PIN         PIND                    </span><span class="comment">/* ICP1 GPIO value      */</span>
<a name="l00038"></a><a class="code" href="icp_8c.html#a2">00038</a> <span class="preprocessor">#define ICP_PORT        PORTD                   </span><span class="comment">/* ICP1 GPIO port       */</span>
<a name="l00039"></a><a class="code" href="icp_8c.html#a3">00039</a> <span class="preprocessor">#define ICP_DDR         DDRD                    </span><span class="comment">/* ICP1 GPIO DDR        */</span>
<a name="l00040"></a><a class="code" href="icp_8c.html#a4">00040</a> <span class="preprocessor">#define ICP_BIT         PD4                             </span><span class="comment">/* ICP1 GPIO pin        */</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="comment">/*</span>
<a name="l00043"></a>00043 <span class="comment"> * Definitions for ICP timer (1) setup.</span>
<a name="l00044"></a>00044 <span class="comment"> */</span>
<a name="l00045"></a><a class="code" href="icp_8c.html#a5">00045</a> <span class="preprocessor">#define ICP_OCR         OCR1A                   </span><span class="comment">/* ICP1 Output Compare register         */</span>
<a name="l00046"></a><a class="code" href="icp_8c.html#a6">00046</a> <span class="preprocessor">#define ICP_OC_IE       OCIE1A                  </span><span class="comment">/* ICP1 timer Output Compare enable */</span>
<a name="l00047"></a><a class="code" href="icp_8c.html#a7">00047</a> <span class="preprocessor">#define ICP_OC_IF       OCF1A                   </span><span class="comment">/* ICP1 timer Output Compare flag       */</span>
<a name="l00048"></a><a class="code" href="icp_8c.html#a8">00048</a> <span class="preprocessor">#define ICP_IE          TICIE1                  </span><span class="comment">/* ICP1 interrupt enable                        */</span>
<a name="l00049"></a><a class="code" href="icp_8c.html#a9">00049</a> <span class="preprocessor">#define ICP_IF          ICF1                    </span><span class="comment">/* ICP1 interrupt flag                          */</span>
<a name="l00050"></a><a class="code" href="icp_8c.html#a10">00050</a> <span class="preprocessor">#define ICP_CTL_A       TCCR1A                  </span><span class="comment">/* ICP1 timer control                           */</span>
<a name="l00051"></a><a class="code" href="icp_8c.html#a11">00051</a> <span class="preprocessor">#define ICP_CTL         TCCR1B                  </span><span class="comment">/* ICP1 interrupt control                       */</span>
<a name="l00052"></a><a class="code" href="icp_8c.html#a12">00052</a> <span class="preprocessor">#define ICP_SENSE       ICES1                   </span><span class="comment">/* ICP1 interrupt sense (rising/falling) */</span>
<a name="l00053"></a><a class="code" href="icp_8c.html#a13">00053</a> <span class="preprocessor">#define ICP_PRESCALE ((0 &lt;&lt; CS12) | (0 &lt;&lt; CS11) | (1 &lt;&lt; CS10))  </span><span class="comment">/* prescale /1 */</span>
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="icp_8c.html#a14">00055</a> <span class="preprocessor">#define ICP_START_SENSE (1 &lt;&lt; ICP_SENSE)        </span><span class="comment">/* start with rising edge       */</span>
<a name="l00056"></a>00056 
<a name="l00065"></a><a class="code" href="icp_8c.html#a15">00065</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="icp_8c.html#a15">icp_timer_t</a>;                       <span class="comment">/* same as TCNT1                */</span>
<a name="l00066"></a><a class="code" href="icp_8c.html#a17">00066</a> <a class="code" href="icp_8c.html#a15">icp_timer_t</a> <a class="code" href="icp_8c.html#a16">icp_start_time</a>, <a class="code" href="icp_8c.html#a17">icp_stop_time</a>;
<a name="l00067"></a><a class="code" href="icp_8c.html#a18">00067</a> <a class="code" href="icp_8c.html#a15">icp_timer_t</a> <a class="code" href="icp_8c.html#a18">icp_period</a>;
<a name="l00068"></a>00068 
<a name="l00076"></a><a class="code" href="icp_8c.html#a19">00076</a> <a class="code" href="icp_8h.html#a5">icp_sample_t</a> <a class="code" href="icp_8c.html#a19">icp_rx_q</a>[<a class="code" href="icp_8h.html#a3">ICP_RX_QSIZE</a>];
<a name="l00077"></a>00077 
<a name="l00088"></a><a class="code" href="icp_8c.html#a20">00088</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="icp_8c.html#a20">icp_rx_tail</a>;              <span class="comment">/* icp_rx_q insertion index */</span>
<a name="l00089"></a>00089 <span class="preprocessor">#if     !ICP_ANALOG     </span><span class="comment">/* ICP_DIGITAL */</span>
<a name="l00090"></a>00090 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> icp_rx_head;              <span class="comment">/* icp_rx_q retrieval index */</span>
<a name="l00091"></a>00091 <span class="preprocessor">#endif</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="preprocessor">#if     ICP_ANALOG</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>
<a name="l00102"></a><a class="code" href="icp_8c.html#a21">00102</a> <a class="code" href="icp_8h.html#a6">icp_total_t</a> <a class="code" href="icp_8c.html#a21">icp_total</a>;
<a name="l00103"></a>00103 <span class="preprocessor">#endif  </span><span class="comment">/* ICP_ANALOG */</span>
<a name="l00104"></a>00104 
<a name="l00117"></a>00117 <span class="preprocessor">#if __GCC__</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span>__inline__
<a name="l00119"></a>00119 <span class="preprocessor">#else   </span><span class="comment">/* assume IAR */</span>
<a name="l00120"></a>00120 <span class="preprocessor">#pragma inline      </span><span class="comment">/* for next function */</span>
<a name="l00121"></a>00121 <span class="preprocessor">#endif</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="icp_8h.html#a5">icp_sample_t</a> icp_duty_compute(<a class="code" href="icp_8c.html#a15">icp_timer_t</a> pulsewidth, <a class="code" href="icp_8c.html#a15">icp_timer_t</a> period)
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124         <a class="code" href="icp_8h.html#a5">icp_sample_t</a> r, mask;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126         mask = <a class="code" href="icp_8h.html#a4">ICP_SCALE</a> &gt;&gt; 1;
<a name="l00127"></a>00127         r = 0;
<a name="l00128"></a>00128         <span class="keywordflow">do</span>
<a name="l00129"></a>00129         {
<a name="l00130"></a>00130                 period &gt;&gt;= 1;
<a name="l00131"></a>00131                 <span class="keywordflow">if</span> (pulsewidth &gt;= period)
<a name="l00132"></a>00132                 {
<a name="l00133"></a>00133                         r |= mask;
<a name="l00134"></a>00134                         pulsewidth -= period;
<a name="l00135"></a>00135                 }
<a name="l00136"></a>00136                 mask &gt;&gt;= 1;
<a name="l00137"></a>00137         } <span class="keywordflow">while</span> (pulsewidth != 0 &amp;&amp; mask != 0);
<a name="l00138"></a>00138         <span class="keywordflow">return</span>(r);
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00146"></a>00146 <span class="preprocessor">#if __GCC__</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span>__inline__
<a name="l00148"></a>00148 <span class="preprocessor">#else   </span><span class="comment">/* assume IAR */</span>
<a name="l00149"></a>00149 <span class="preprocessor">#pragma inline      </span><span class="comment">/* for next function */</span>
<a name="l00150"></a>00150 <span class="preprocessor">#endif</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> icp_enq(<a class="code" href="icp_8h.html#a5">icp_sample_t</a> sample)
<a name="l00152"></a>00152 {
<a name="l00153"></a>00153         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> t;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155         t = <a class="code" href="icp_8c.html#a20">icp_rx_tail</a>;
<a name="l00156"></a>00156 <span class="preprocessor">#if     ICP_ANALOG</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span>        <a class="code" href="icp_8c.html#a21">icp_total</a> += sample - <a class="code" href="icp_8c.html#a19">icp_rx_q</a>[t];
<a name="l00158"></a>00158 <span class="preprocessor">#endif</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>        icp_rx_q[t] = sample;
<a name="l00160"></a>00160         <span class="keywordflow">if</span> (++t &gt;= <a class="code" href="icp_8h.html#a3">ICP_RX_QSIZE</a>)
<a name="l00161"></a>00161                 t = 0;
<a name="l00162"></a>00162 <span class="preprocessor">#if     !ICP_ANALOG</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (t != icp_rx_head)           <span class="comment">/* digital: Check for Rx overrun */</span>
<a name="l00164"></a>00164 <span class="preprocessor">#endif</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>                <a class="code" href="icp_8c.html#a20">icp_rx_tail</a> = t;
<a name="l00166"></a>00166         <span class="keywordflow">return</span>;
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00178"></a>00178 <span class="preprocessor">#if __GCC__</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span>SIGNAL(SIG_OUTPUT_COMPARE1A)
<a name="l00180"></a>00180 #<span class="keywordflow">else</span>   <span class="comment">/* assume IAR */</span>
<a name="l00181"></a>00181 <span class="preprocessor">#pragma vector=TIMER1_COMPA_vect</span>
<a name="l00182"></a><a class="code" href="icp_8c.html#a24">00182</a> <span class="preprocessor"></span>__interrupt <span class="keywordtype">void</span> <a class="code" href="icp_8c.html#a24">TIMER1_COMPA</a>(<span class="keywordtype">void</span>)
<a name="l00183"></a>00183 #endif
<a name="l00184"></a>00184 {
<a name="l00185"></a>00185         <a class="code" href="icp_8h.html#a5">icp_sample_t</a> sample;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         <a class="code" href="icp_8c.html#a5">ICP_OCR</a> += <a class="code" href="icp_8c.html#a18">icp_period</a>;          <span class="comment">/* slide timeout window forward */</span>
<a name="l00188"></a>00188         sample = 0;                                     <span class="comment">/* assume 0%    */</span>
<a name="l00189"></a>00189         <span class="keywordflow">if</span> ((<a class="code" href="icp_8c.html#a11">ICP_CTL</a> &amp; (1 &lt;&lt; <a class="code" href="icp_8c.html#a12">ICP_SENSE</a>)) != <a class="code" href="icp_8c.html#a14">ICP_START_SENSE</a>)
<a name="l00190"></a>00190                 sample = <a class="code" href="icp_8h.html#a4">ICP_SCALE</a> - 1; <span class="comment">/* 100% */</span>
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         icp_enq(sample);
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         <span class="keywordflow">return</span>;
<a name="l00195"></a>00195 }
<a name="l00196"></a>00196 
<a name="l00202"></a>00202 <span class="preprocessor">#if __GCC__</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span>SIGNAL(SIG_INPUT_CAPTURE1)
<a name="l00204"></a>00204 #<span class="keywordflow">else</span>   <span class="comment">/* assume IAR */</span>
<a name="l00205"></a>00205 <span class="preprocessor">#pragma vector=TIMER1_CAPT_vect</span>
<a name="l00206"></a><a class="code" href="icp_8c.html#a25">00206</a> <span class="preprocessor"></span>__interrupt <span class="keywordtype">void</span> <a class="code" href="icp_8c.html#a25">TIMER1_CAPT</a>(<span class="keywordtype">void</span>)
<a name="l00207"></a>00207 #endif
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209         <a class="code" href="icp_8c.html#a15">icp_timer_t</a> icr, delta;
<a name="l00210"></a>00210         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tccr1b;
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         <span class="comment">/*</span>
<a name="l00213"></a>00213 <span class="comment">         * Capture the ICR and then reverse the sense of the capture.</span>
<a name="l00214"></a>00214 <span class="comment">         * These must be done in this order, since as soon as the</span>
<a name="l00215"></a>00215 <span class="comment">         * sense is reversed it is possible for ICR to be updated again.</span>
<a name="l00216"></a>00216 <span class="comment">         */</span>
<a name="l00217"></a>00217         icr = ICR1;                                                     <span class="comment">/* capture timestamp    */</span>
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         <span class="keywordflow">do</span>
<a name="l00220"></a>00220         {
<a name="l00221"></a>00221                 tccr1b = <a class="code" href="icp_8c.html#a11">ICP_CTL</a>;
<a name="l00222"></a>00222                 <a class="code" href="icp_8c.html#a11">ICP_CTL</a> = tccr1b ^ (1 &lt;&lt; <a class="code" href="icp_8c.html#a12">ICP_SENSE</a>);            <span class="comment">/* reverse sense                */</span>
<a name="l00223"></a>00223         
<a name="l00224"></a>00224                 <span class="comment">/*</span>
<a name="l00225"></a>00225 <span class="comment">                 * If we were waiting for a start edge, then this is the</span>
<a name="l00226"></a>00226 <span class="comment">                 * end/beginning of a period.</span>
<a name="l00227"></a>00227 <span class="comment">                 */</span>
<a name="l00228"></a>00228                 <span class="keywordflow">if</span> ((tccr1b &amp; (1 &lt;&lt; <a class="code" href="icp_8c.html#a12">ICP_SENSE</a>)) == <a class="code" href="icp_8c.html#a14">ICP_START_SENSE</a>)
<a name="l00229"></a>00229                 {
<a name="l00230"></a>00230                         <span class="comment">/*</span>
<a name="l00231"></a>00231 <span class="comment">                         * Beginning of pulse: Compute length of preceding period,</span>
<a name="l00232"></a>00232 <span class="comment">                         * and thence the duty cycle of the preceding pulse.</span>
<a name="l00233"></a>00233 <span class="comment">                         */</span>
<a name="l00234"></a>00234                         <a class="code" href="icp_8c.html#a18">icp_period</a> = icr - <a class="code" href="icp_8c.html#a16">icp_start_time</a>;      <span class="comment">/* Length of previous period */</span>
<a name="l00235"></a>00235                         delta = <a class="code" href="icp_8c.html#a17">icp_stop_time</a> - icp_start_time; <span class="comment">/* Length of previous pulse */</span>
<a name="l00236"></a>00236                         icp_start_time = icr;                           <span class="comment">/* Start of new pulse/period */</span>
<a name="l00237"></a>00237 
<a name="l00238"></a>00238                         <span class="comment">/*</span>
<a name="l00239"></a>00239 <span class="comment">                         * Update the timeout based on the new period. (The new period</span>
<a name="l00240"></a>00240 <span class="comment">                         * is probably the same as the old, give or take clock drift.)</span>
<a name="l00241"></a>00241 <span class="comment">                         * We add 1 to make fairly sure that, in case of competition,</span>
<a name="l00242"></a>00242 <span class="comment">                         * the PWM edge takes precedence over the timeout.</span>
<a name="l00243"></a>00243 <span class="comment">                         */</span>
<a name="l00244"></a>00244                         <a class="code" href="icp_8c.html#a5">ICP_OCR</a> = icr + <a class="code" href="icp_8c.html#a18">icp_period</a> + 1;         <span class="comment">/* Move timeout window          */</span>
<a name="l00245"></a>00245                         TIFR = (1 &lt;&lt; <a class="code" href="icp_8c.html#a7">ICP_OC_IF</a>);                        <span class="comment">/* Clear in case of race        */</span>
<a name="l00246"></a>00246 
<a name="l00247"></a>00247                         <span class="comment">/*</span>
<a name="l00248"></a>00248 <span class="comment">                         * Compute the duty cycle, and store the new reading.</span>
<a name="l00249"></a>00249 <span class="comment">                         */</span>
<a name="l00250"></a>00250                         icp_enq(icp_duty_compute(delta,icp_period));
<a name="l00251"></a>00251         
<a name="l00252"></a>00252                         <span class="comment">/*</span>
<a name="l00253"></a>00253 <span class="comment">                         * Check for a race condition where a (very) short pulse</span>
<a name="l00254"></a>00254 <span class="comment">                         * ended before we could reverse the sense above.</span>
<a name="l00255"></a>00255 <span class="comment">                         * If the ICP pin is still high (as expected) OR the IF is</span>
<a name="l00256"></a>00256 <span class="comment">                         * set (the falling edge has happened, but we caught it),</span>
<a name="l00257"></a>00257 <span class="comment">                         * then we won the race, so we're done for now.</span>
<a name="l00258"></a>00258 <span class="comment">                         */</span>
<a name="l00259"></a>00259                         <span class="keywordflow">if</span> ((<a class="code" href="icp_8c.html#a1">ICP_PIN</a> &amp; (1 &lt;&lt; <a class="code" href="icp_8c.html#a4">ICP_BIT</a>)) || (TIFR &amp; (1 &lt;&lt; <a class="code" href="icp_8c.html#a9">ICP_IF</a>)))
<a name="l00260"></a>00260                                 <span class="keywordflow">break</span>;
<a name="l00261"></a>00261                 }
<a name="l00262"></a>00262                 <span class="keywordflow">else</span>
<a name="l00263"></a>00263                 {
<a name="l00264"></a>00264                         <span class="comment">/*</span>
<a name="l00265"></a>00265 <span class="comment">                         * Falling edge detected, so this is the end of the pulse.</span>
<a name="l00266"></a>00266 <span class="comment">                         * The time is simply recorded here; the final computation</span>
<a name="l00267"></a>00267 <span class="comment">                         * will take place at the beginning of the next pulse.</span>
<a name="l00268"></a>00268 <span class="comment">                         */</span>
<a name="l00269"></a>00269                         <a class="code" href="icp_8c.html#a17">icp_stop_time</a> = icr;            <span class="comment">/* Capture falling-edge time */</span>
<a name="l00270"></a>00270 
<a name="l00271"></a>00271                         <span class="comment">/*</span>
<a name="l00272"></a>00272 <span class="comment">                         * If the ICP pin is still low (as expected) OR the IF is</span>
<a name="l00273"></a>00273 <span class="comment">                         * set (the transition was caught anyway) we won the race,</span>
<a name="l00274"></a>00274 <span class="comment">                         * so we're done for now.</span>
<a name="l00275"></a>00275 <span class="comment">                         */</span>
<a name="l00276"></a>00276                         <span class="keywordflow">if</span> ((!(<a class="code" href="icp_8c.html#a1">ICP_PIN</a> &amp; (1 &lt;&lt; <a class="code" href="icp_8c.html#a4">ICP_BIT</a>))) || (TIFR &amp; (1 &lt;&lt; <a class="code" href="icp_8c.html#a9">ICP_IF</a>)))
<a name="l00277"></a>00277                                 <span class="keywordflow">break</span>;
<a name="l00278"></a>00278                 }
<a name="l00279"></a>00279                 <span class="comment">/*</span>
<a name="l00280"></a>00280 <span class="comment">                 * If we got here, we lost the race with a very short/long pulse.</span>
<a name="l00281"></a>00281 <span class="comment">                 * We now loop, pretending (as it were) that we caught the transition.</span>
<a name="l00282"></a>00282 <span class="comment">                 * The Same ICR value is used, so the effect is that we declare</span>
<a name="l00283"></a>00283 <span class="comment">                 * the duty cycle to be 0% or 100% as appropriate.</span>
<a name="l00284"></a>00284 <span class="comment">                 */</span>
<a name="l00285"></a>00285         } <span class="keywordflow">while</span> (1);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287         <span class="keywordflow">return</span>;
<a name="l00288"></a>00288 }
<a name="l00289"></a>00289 
<a name="l00297"></a>00297 <a class="code" href="icp_8h.html#a5">icp_sample_t</a>
<a name="l00298"></a><a class="code" href="icp_8h.html#a8">00298</a> <a class="code" href="icp_8c.html#a26">icp_rx</a>(<span class="keywordtype">void</span>)
<a name="l00299"></a>00299 {
<a name="l00300"></a>00300         <a class="code" href="icp_8h.html#a5">icp_sample_t</a> r;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 <span class="preprocessor">#if     ICP_ANALOG</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span>        r = <a class="code" href="icp_8c.html#a21">icp_total</a> / <a class="code" href="icp_8h.html#a3">ICP_RX_QSIZE</a>;           <span class="comment">/* moving average of last QSIZE samples */</span>
<a name="l00304"></a>00304 <span class="preprocessor">#else   </span><span class="comment">/* ICP_DIGITAL */</span>
<a name="l00305"></a>00305         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> h;
<a name="l00306"></a>00306 
<a name="l00307"></a>00307         h = icp_rx_head;
<a name="l00308"></a>00308         <span class="keywordflow">if</span> (h == <a class="code" href="icp_8c.html#a20">icp_rx_tail</a>)                           <span class="comment">/* if head == tail, queue is empty */</span>
<a name="l00309"></a>00309                 r = (<a class="code" href="icp_8h.html#a5">icp_sample_t</a>)-1;
<a name="l00310"></a>00310         <span class="keywordflow">else</span>
<a name="l00311"></a>00311         {
<a name="l00312"></a>00312                 r = icp_rx_q[h];                                <span class="comment">/* fetch next entry                             */</span>
<a name="l00313"></a>00313                 <span class="keywordflow">if</span> (++h &gt;= <a class="code" href="icp_8h.html#a3">ICP_RX_QSIZE</a>)                <span class="comment">/* increment head, modulo QSIZE */</span>
<a name="l00314"></a>00314                         h = 0;
<a name="l00315"></a>00315                 icp_rx_head = h;
<a name="l00316"></a>00316         }
<a name="l00317"></a>00317 <span class="preprocessor">#endif  </span><span class="comment">/* ICP_DIGITAL */</span>
<a name="l00318"></a>00318 
<a name="l00319"></a>00319         <span class="keywordflow">return</span>(r);
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 
<a name="l00327"></a>00327 <span class="keywordtype">void</span>
<a name="l00328"></a><a class="code" href="icp_8h.html#a7">00328</a> <a class="code" href="icp_8c.html#a27">icp_init</a>(<span class="keywordtype">void</span>)
<a name="l00329"></a>00329 {
<a name="l00330"></a>00330         <span class="comment">/*</span>
<a name="l00331"></a>00331 <span class="comment">         * Nothing interesting to set in TCCR1A</span>
<a name="l00332"></a>00332 <span class="comment">         */</span>
<a name="l00333"></a>00333         <a class="code" href="icp_8c.html#a10">ICP_CTL_A</a> = 0;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335         <span class="comment">/*</span>
<a name="l00336"></a>00336 <span class="comment">         * Setting the OCR (timeout) to 0 allows the full TCNT range for</span>
<a name="l00337"></a>00337 <span class="comment">         * the initial period.</span>
<a name="l00338"></a>00338 <span class="comment">         */</span>
<a name="l00339"></a>00339         <a class="code" href="icp_8c.html#a5">ICP_OCR</a> = 0;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341         <span class="comment">/*</span>
<a name="l00342"></a>00342 <span class="comment">         * Set the interrupt sense and the prescaler</span>
<a name="l00343"></a>00343 <span class="comment">         */</span>
<a name="l00344"></a>00344         <a class="code" href="icp_8c.html#a11">ICP_CTL</a> = <a class="code" href="icp_8c.html#a14">ICP_START_SENSE</a> | <a class="code" href="icp_8c.html#a13">ICP_PRESCALE</a>;
<a name="l00345"></a>00345 
<a name="l00346"></a>00346         <span class="comment">/*</span>
<a name="l00347"></a>00347 <span class="comment">         *      Enable both the Input Capture and the Output Capture interrupts.</span>
<a name="l00348"></a>00348 <span class="comment">         *      The latter is used for timeout (0% and 100%) checking.</span>
<a name="l00349"></a>00349 <span class="comment">         */</span>
<a name="l00350"></a>00350         TIMSK   |= (1 &lt;&lt; <a class="code" href="icp_8c.html#a8">ICP_IE</a>) | (1 &lt;&lt; <a class="code" href="icp_8c.html#a6">ICP_OC_IE</a>);
<a name="l00351"></a>00351 
<a name="l00352"></a>00352         <span class="keywordflow">return</span>;
<a name="l00353"></a>00353 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Nov 2 14:20:47 2005 for AVR135: Using Timer Capture to Measure PWM Duty Cycle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
